<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<!-- SEO Meta Tags -->
<meta name="description" content="A lot of people focus on software technology for speed, like dictionaries, and parallelism... but rarely have I seen developers actually... - v/programming">
<meta name="keywords" content="programming, hard, disk, software, actually, from, flat, fastest, developing, read">
<meta name="author" content="Redd Archive Demo">
<meta name="robots" content="index, follow">
<link rel="canonical" href="https://online-archives.github.io/redd-archiver-example/v/programming/comments/323413.html">

<!-- Open Graph Tags -->
<meta property="og:title" content="v/programming: Developing for speed: Know your hard disk.">
<meta property="og:description" content="A lot of people focus on software technology for speed, like dictionaries, and parallelism... but rarely have I seen developers actually... - v/programming">
<meta property="og:type" content="article">
<meta property="og:url" content="https://online-archives.github.io/redd-archiver-example/v/programming/comments/323413.html">
<meta property="og:site_name" content="Redd Archive Demo">

<!-- Twitter Card Tags -->
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="v/programming: Developing for speed: Know your hard disk.">
<meta name="twitter:description" content="A lot of people focus on software technology for speed, like dictionaries, and parallelism... but rarely have I seen developers actually... - v/programming">

    <!-- Favicon -->
<link rel="icon" href="../../../../static/favicon.ico" sizes="32x32">
    <link rel="icon" href="../../../../static/favicon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="../../../../static/apple-touch-icon.png">
    <link rel="manifest" href="../../../../static/site.webmanifest">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "DiscussionForumPosting",
  "headline": "Developing for speed: Know your hard disk.",
  "author": {
    "@type": "Person",
    "name": "roznak"
  },
  "datePublished": "2015-07-21T20:03:30Z",
  "interactionStatistic": {
    "@type": "InteractionCounter",
    "interactionType": "https://schema.org/CommentAction",
    "userInteractionCount": 1
  },
  "isPartOf": {
    "@type": "WebSite",
    "name": "v/programming Archive",
    "url": "https://online-archives.github.io/redd-archiver-example"
  },
  "text": "A lot of people focus on software technology for speed, like dictionaries, and parallelism... but rarely have I seen developers actually understand what they are doing. Know your hardware it will run on. That can speed up far more than software solutions. Data on your hard disk, I am now testing read speeds from my hard disks (actually test them on defects) and see something interesting. One hard disk has a flat data transmission. The drive is incredibly fast when it is at the beginning of the..."
}
</script>
    <!-- Font preload removed - using system fonts for instant rendering -->

    <!-- Theme Toggle -->
    <input type="checkbox" id="dark-theme-toggle">

    <!-- Universal CSS Build -->
    <link rel="stylesheet" href="../../../../static/css/redd-archiver-universal.css">


    <title>v/programming: Developing for speed: Know your hard disk.</title>
  </head>
  <body>
    <div class="site-content">
<header>
  <nav class="navbar navbar-expand-sm navbar-dark bg-primary">
    <a class="navbar-brand" href="../../../../v/programming/index.html">v/programming</a>
    <input type="checkbox" id="navbar-toggle" class="navbar-toggle">
    <label for="navbar-toggle" class="navbar-toggler" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </label>
    <div class="navbar-collapse" id="navbarNav">
      <ul class="navbar-nav">
        <li class="nav-item">
          <a class="nav-link" href="../../../../v/programming/index.html">score</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../../../../v/programming/index-comments/index.html">comments</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../../../../v/programming/index-date/index.html">date</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../../../../search">search</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../../../../index.html">home</a>
        </li>
        <li class="nav-item">
          <label for="dark-theme-toggle" class="nav-link theme-toggle" title="Toggle dark theme"></label>
        </li>
      </ul>
    </div>
  </nav>
</header>

    <main role="main" class="container-fluid">
<div class="submission pt-3" data-id="voat_323413">
  <h3 class="title">
      Developing for speed: Know your hard disk.
    
    
    
    
    
    
  </h3>
  <p>
    <span class="badge badge-primary" title="Score: 1">1</span>
    &nbsp;&nbsp;
    <span title="Posted: 2015-07-21 20:03:30 UTC">21 Jul 2015 20:03</span>
    by <span ><a class="user-link" href="../../../../user/roznak/">u/roznak</a>
</span>
    
    
    <span title=""></span>
  </p>
  <div class="card mt-3 mb-3">
    <div class="card-body">
      <div class="md"><p>A lot of people focus on software technology for speed, like dictionaries, and parallelism... but rarely have I seen developers actually understand what they are doing.</p>
<p>Know your hardware it will run on. That can speed up far more than software solutions.
Data on your hard disk, I am now testing read speeds from my hard disks (actually test them on defects) and see something interesting.</p>
<ul>
<li>One hard disk has a flat data transmission. The drive is incredibly fast when it is at the beginning of the hard disk, but slows down 50% when the data is at the end of the hard disk.</li>
<li>One hard drive has a flat curve. No matter where the data is read from it stays constant.</li>
</ul>
<p>My experience with developing for speed is make different versions of optimizations, and let the software select the one that works fastest for him by actually measuring which one is the fastest for that computer.</p>
<p>e.g. When it detects one of the drives that does not have a flat curve, put the data where it gets is  fastest, even distribute it over different hard-disk first before filling up the one hard-disk and continue to the other one. This could also mean that you have to fill  fake data on the hard disk to get the most optimized data in the right spot.</p>
<p>Edit: Added some graphics about disk speed: <a href="https://slimgur.com/image/01y">https://slimgur.com/image/01y</a></p>
<p>The graphics clearly demonstrates that you lose 70% to 90% of data reading from a hard disk depending on the location of that data on the hard disk. Not filling up your hard disk so that your data is located more to the start can almost double your speed compared to the data on a too full hard disk.</p></div>
    </div>
  </div>
</div>

<div class="comments">
  <h4>3 comments</h4>
        <details class="comment "
         id="comment-voat_1256742"
         data-depth="0"
         data-id="voat_1256742"
open>
    <summary class="comment-header">
        <span class="badge badge-warning-orange"
              title="Comment score: 0">
            0
        </span>
        <span class="byline text-muted">
            <span >
                <a class="user-link" href="../../../../user/leixiaotie/">u/leixiaotie</a>

            </span>
            
            
            
            <span title="Posted: 2015-07-22 09:05:51 UTC">22 Jul 2015 09:05</span>
        </span>
    </summary>
    <div class="md"><p>Context is needed here.</p>
<p>For programming language closer with hardware such as C/C++ and assembly maybe your point is on the spot here.</p>
<p>For higher one such as Java and C#, the function that you are describing here is not applicable, since in those language the function has been abstracted and handled behind the scene.</p>
<p>And not every apps using hard disk to operate. I think the people will like to discuss more general-applicable case rather than specific like this.</p></div>
            <details class="comment "
         id="comment-voat_1271749"
         data-depth="1"
         data-id="voat_1271749"
open>
    <summary class="comment-header">
        <span class="badge badge-warning-orange"
              title="Comment score: 0">
            0
        </span>
        <span class="byline text-muted">
            <span >
                <a class="user-link" href="../../../../user/roznak/">u/roznak</a>

            </span>
                <span class="op-badge" title="Original Poster">[OP]</span>
            
            
            
            <span title="Posted: 2015-07-22 21:41:38 UTC">22 Jul 2015 21:41</span>
        </span>
    </summary>
    <div class="md"><p>No it is not C++ only, it is every language that gets influenced. The hard disk is the bottle neck no matter how fast the language generated code. It must wait for the hart disk data to be read or to be written.</p>
<p>I have the intention to put some graphs up, I am  here testing my hard disks and I do notice one hard disk a completely flat curve, one that basically loses its read speed by half, and another one that also have a curve (lose read speed the further it gets) but more slowly. So by not filling your hard disk can actually double the processing speed, or from other point of view, filling your hard disk might slow your processing down by 50%.</p>
<p>I do not know about Java, but C# can escape its abstraction and can go screaming fast that almost gets as close as C++. With the benefits that your project can be developed in weeks instead of months. C++ can't go any faster because it is bound to Windows functions. C# can use these same windows functions that C++ can. </p>
<p>The C++ code can be better processor optimized however that microsecond it wins does not add up to the milliseconds it needs to read in 100 bytes.</p>
<p>In this comment I was focusing on hard disks. Understanding the hardware it has to work on can greatly improve performance.</p></div>
            <details class="comment "
         id="comment-voat_1281393"
         data-depth="2"
         data-id="voat_1281393"
open>
    <summary class="comment-header">
        <span class="badge badge-warning-orange"
              title="Comment score: 0">
            0
        </span>
        <span class="byline text-muted">
            <span >
                <a class="user-link" href="../../../../user/leixiaotie/">u/leixiaotie</a>

            </span>
            
            
            
            <span title="Posted: 2015-07-23 03:57:50 UTC">23 Jul 2015 03:57</span>
        </span>
    </summary>
    <div class="md"><p>In C#, I just found <a href="http://stackoverflow.com/questions/1399485/direct-disk-access-in-windows-c">this</a>. It is using winapi or similar lower module to do direct access to harddisk.</p>
<p>I still believe that the majority of higher-level abstraction language such as C# and java don't have many harddisk operation. Most of them provide memory processing or they are using database as storage instead.  The file saving operation usually lower than 10 mB. Don't know about C/C++, but I think it should be around the same.</p>
<p>So in non-intensive harddisk operation apps, the technique to direct access harddisk is overkill. A more general performance optimization such as sorting algorithm can be used almost anywhere that involve sorting.</p>
<p>I don't say that your tips isn't useful or significant. I just stated why there is lack of interest of direct-hardware operation, compared to general-applicable optimization such as algorithm. Moreover, hardware is different from one and another, such as NAS-hdd, make it harder to do programming through hardware.</p></div>
</details>

</details>

</details>

</div>
    </main>

<footer class="container-fluid">
  <a class="to-top mt-1 mb-1 btn btn-lg btn-primary" href="#top">top of page</a>
  <p class="small mb-0">
    last archived 28 Apr 2020
    <a href="https://github.com/19-84/redd-archiver">source code</a>
  </p>
</footer>
    </div>

  </body>
</html>