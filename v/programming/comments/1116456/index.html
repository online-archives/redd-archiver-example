<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<!-- SEO Meta Tags -->
<meta name="description" content="We are presently living in a world where programming can be broadly categorized into these two paradigms as far as parallelism is concerned... - v/programming">
<meta name="keywords" content="programming, code, multi, threading, based, programming, like, etc, bound, million">
<meta name="author" content="Redd Archive Demo">
<meta name="robots" content="index, follow">
<link rel="canonical" href="https://online-archives.github.io/redd-archiver-example/v/programming/comments/1116456.html">

<!-- Open Graph Tags -->
<meta property="og:title" content="v/programming: Between &#34;async event based&#34; and &#34;multi-threading&#34; programming models, which one gives better performance and why?">
<meta property="og:description" content="We are presently living in a world where programming can be broadly categorized into these two paradigms as far as parallelism is concerned... - v/programming">
<meta property="og:type" content="article">
<meta property="og:url" content="https://online-archives.github.io/redd-archiver-example/v/programming/comments/1116456.html">
<meta property="og:site_name" content="Redd Archive Demo">

<!-- Twitter Card Tags -->
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="v/programming: Between &#34;async event based&#34; and &#34;multi-threading&#34; programming models, which one gives better performance and why?">
<meta name="twitter:description" content="We are presently living in a world where programming can be broadly categorized into these two paradigms as far as parallelism is concerned... - v/programming">

    <!-- Favicon -->
<link rel="icon" href="../../../../static/favicon.ico" sizes="32x32">
    <link rel="icon" href="../../../../static/favicon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="../../../../static/apple-touch-icon.png">
    <link rel="manifest" href="../../../../static/site.webmanifest">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "DiscussionForumPosting",
  "headline": "Between \"async event based\" and \"multi-threading\" programming models, which one gives better performance and why?",
  "author": {
    "@type": "Person",
    "name": "prahladyeri"
  },
  "datePublished": "2016-06-18T01:57:38Z",
  "interactionStatistic": {
    "@type": "InteractionCounter",
    "interactionType": "https://schema.org/CommentAction",
    "userInteractionCount": 5
  },
  "isPartOf": {
    "@type": "WebSite",
    "name": "v/programming Archive",
    "url": "https://online-archives.github.io/redd-archiver-example"
  },
  "text": "We are presently living in a world where programming can be broadly categorized into these two paradigms as far as parallelism is concerned (there are many others like OOP, procedural, functional, etc. in other departments: async event based and multi-threading based. In the category of multi-threading, we have traditional languages like Java, C#, Python, PHP, etc. who all support multi-threading to some extent, either in a clean way using threads, mutexes, semaphores, etc. or using some hacks...."
}
</script>
    <!-- Font preload removed - using system fonts for instant rendering -->

    <!-- Theme Toggle -->
    <input type="checkbox" id="dark-theme-toggle">

    <!-- Universal CSS Build -->
    <link rel="stylesheet" href="../../../../static/css/redd-archiver-universal.css">


    <title>v/programming: Between &#34;async event based&#34; and &#34;multi-threading&#34; programming models, which one gives better performance and why?</title>
  </head>
  <body>
    <div class="site-content">
<header>
  <nav class="navbar navbar-expand-sm navbar-dark bg-primary">
    <a class="navbar-brand" href="../../../../v/programming/index.html">v/programming</a>
    <input type="checkbox" id="navbar-toggle" class="navbar-toggle">
    <label for="navbar-toggle" class="navbar-toggler" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </label>
    <div class="navbar-collapse" id="navbarNav">
      <ul class="navbar-nav">
        <li class="nav-item">
          <a class="nav-link" href="../../../../v/programming/index.html">score</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../../../../v/programming/index-comments/index.html">comments</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../../../../v/programming/index-date/index.html">date</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../../../../search">search</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../../../../index.html">home</a>
        </li>
        <li class="nav-item">
          <label for="dark-theme-toggle" class="nav-link theme-toggle" title="Toggle dark theme"></label>
        </li>
      </ul>
    </div>
  </nav>
</header>

    <main role="main" class="container-fluid">
<div class="submission pt-3" data-id="voat_1116456">
  <h3 class="title">
      Between &#34;async event based&#34; and &#34;multi-threading&#34; programming models, which one gives better performance and why?
    
    
    
    
    
    
  </h3>
  <p>
    <span class="badge badge-primary" title="Score: 11">11</span>
    &nbsp;&nbsp;
    <span title="Posted: 2016-06-18 01:57:38 UTC">18 Jun 2016 01:57</span>
    by <span ><a class="user-link" href="../../../../user/prahladyeri/">u/prahladyeri</a>
</span>
    
    
    <span title=""></span>
  </p>
  <div class="card mt-3 mb-3">
    <div class="card-body">
      <div class="md"><p>We are presently living in a world where programming can be broadly categorized into these two paradigms as far as parallelism is concerned (there are many others like OOP, procedural, functional, etc. in other departments: <em>async event based</em> and <em>multi-threading</em> based.</p>
<p>In the category of <em>multi-threading</em>, we have traditional languages like Java, C#, Python, PHP, etc. who all support multi-threading to some extent, either in a clean way using threads, mutexes, semaphores, etc. or using some hacks.</p>
<p>In the category of <em>asynchronous even based</em> model OTOH, we have client-side <code>JavaScript</code> and server-side <code>Node.JS</code> which are also time-tested and proven to be fast.</p>
<p>Besides, the recent advice given is that if your app is <code>I/O</code> bound, then go for Node.JS, otherwise, if the app is more <code>CPU</code> bound, then go with more traditional languages like PHP.</p>
<p>But apps in today's world are much more complex than that and rarely can they be classified as <code>I/O</code> bound or <code>CPU</code> bound, can they? My question is that in general, which programming model gives a better performance and why?</p>
<p>I don't know much about system programming, but the trade offs generally go something like this:</p>
<p>With <em>multi-threading</em>, you have the overhead of more threads to handle. For example, Apache creates a new thread for each and every request from the user. If a million users came in suddenly, then a million threads are created. Now, to keep track of what each thread is doing, getting results from each other one by one, etc. is going to cause a lot of overhead, isn't it? Plus, each will consume its own memory space, so there is a chance that your RAM might have already been over-flooded, right?</p>
<p>But in case of Node.JS, there is only a single thread running, be it one or million users. This means, you don't have the thread <code>context switching overhead</code> that you have in case of apache, but if one single thread handles a million requests in a single event loop, is that going to cause any problems to it? I don't have any idea, but that's what I want to ask to you experts out there.</p></div>
    </div>
  </div>
</div>

<div class="comments">
  <h4>10 comments</h4>
        <details class="comment "
         id="comment-voat_5546612"
         data-depth="0"
         data-id="voat_5546612"
open>
    <summary class="comment-header">
        <span class="badge badge-success-bright"
              title="Comment score: 5">
            5
        </span>
        <span class="byline text-muted">
            <span >
                <a class="user-link" href="../../../../user/roznak/">u/roznak</a>

            </span>
            
            
            
            <span title="Posted: 2016-06-18 02:26:18 UTC">18 Jun 2016 02:26</span>
        </span>
    </summary>
    <div class="md"><p>In software you choose the tools and technology depending on your program you want to built. What is even more important in multi-threaded models is not asynch versus multi threaded but how you design your application.</p>
<p>Now how do you know which is better? You can't deduce it, you must measure it. And you can only measure it by building different variations of your code. </p>
<p>Edit: I want to expand on that. You build your code in such a way that you have small functions that can be used in both async and multi threaded solutions. If you create these functions thread safe (but avoid locks as much as possible) then you can use it in both systems depending on your needs.</p></div>
            <details class="comment "
         id="comment-voat_5549590"
         data-depth="1"
         data-id="voat_5549590"
open>
    <summary class="comment-header">
        <span class="badge badge-warning-orange"
              title="Comment score: 0">
            0
        </span>
        <span class="byline text-muted">
            <span >
                <a class="user-link" href="../../../../user/SlappyHo/">u/SlappyHo</a>

            </span>
            
            
            
            <span title="Posted: 2016-06-18 12:29:28 UTC">18 Jun 2016 12:29</span>
        </span>
    </summary>
    <div class="md"><blockquote>
<p>but avoid locks as much as possible</p>
</blockquote>
<p>Locks are fine if you know how to use them, ie limiting to the critical sections only.</p></div>
            <details class="comment "
         id="comment-voat_5549717"
         data-depth="2"
         data-id="voat_5549717"
open>
    <summary class="comment-header">
        <span class="badge badge-light"
              title="Comment score: 1">
            1
        </span>
        <span class="byline text-muted">
            <span >
                <a class="user-link" href="../../../../user/roznak/">u/roznak</a>

            </span>
            
            
            
            <span title="Posted: 2016-06-18 12:55:37 UTC">18 Jun 2016 12:55</span>
        </span>
    </summary>
    <div class="md"><p>But every lock is a potential chance of a bottleneck. Writing your code in such a way that you have almost no locks is preferred. </p></div>
            <details class="comment "
         id="comment-voat_5549740"
         data-depth="3"
         data-id="voat_5549740"
open>
    <summary class="comment-header">
        <span class="badge badge-warning-orange"
              title="Comment score: 0">
            0
        </span>
        <span class="byline text-muted">
            <span >
                <a class="user-link" href="../../../../user/SlappyHo/">u/SlappyHo</a>

            </span>
            
            
            
            <span title="Posted: 2016-06-18 13:01:17 UTC">18 Jun 2016 13:01</span>
        </span>
    </summary>
    <div class="md"><p>Yes, hence critical sections only.</p></div>
            <details class="comment "
         id="comment-voat_5549781"
         data-depth="4"
         data-id="voat_5549781"
open>
    <summary class="comment-header">
        <span class="badge badge-warning-orange"
              title="Comment score: 0">
            0
        </span>
        <span class="byline text-muted">
            <span >
                <a class="user-link" href="../../../../user/roznak/">u/roznak</a>

            </span>
            
            
            
            <span title="Posted: 2016-06-18 13:11:23 UTC">18 Jun 2016 13:11</span>
        </span>
    </summary>
    <div class="md"><p>Even critical sections should be avoided if possible. Every lock that fails adds stalling time and increases the chance that the next thread that wants to lock this part will end up waiting. It all depends of how long that code is locked. </p>
<p>Every lock in your code creates an expectational stall curve. Not having locks in the first place has a linearized the stall curves. Not having locks means that you have to rewrite your code and maybe use a bit more memory. </p></div>
            <details class="comment "
         id="comment-voat_5549860"
         data-depth="5"
         data-id="voat_5549860"
open>
    <summary class="comment-header">
        <span class="badge badge-warning-orange"
              title="Comment score: 0">
            0
        </span>
        <span class="byline text-muted">
            <span >
                <a class="user-link" href="../../../../user/SlappyHo/">u/SlappyHo</a>

            </span>
            
            
            
            <span title="Posted: 2016-06-18 13:25:43 UTC">18 Jun 2016 13:25</span>
        </span>
    </summary>
    <div class="md"><p>sounds good in theory, but in practice its not always possible because:</p>
<blockquote>
<p>maybe use a bit more memory</p>
</blockquote>
<p>Is a constraint in and of itself.</p></div>
</details>

</details>

</details>

</details>

</details>

</details>

        <details class="comment "
         id="comment-voat_5548132"
         data-depth="0"
         data-id="voat_5548132"
open>
    <summary class="comment-header">
        <span class="badge badge-success-bright"
              title="Comment score: 5">
            5
        </span>
        <span class="byline text-muted">
            <span >
                <a class="user-link" href="../../../../user/dickvomit/">u/dickvomit</a>

            </span>
            
            
            
            <span title="Posted: 2016-06-18 05:53:56 UTC">18 Jun 2016 05:53</span>
        </span>
    </summary>
    <div class="md"><p>Systems programmer here who's worked on both for more than a decade, I'll try my best to describe the tradeoffs I've learned and used, though my background is entirely C and C++.</p>
<p>First, &quot;async event based&quot; is common and necessary in threaded environments, so lets call the two competing solutions &quot;thread based&quot; and &quot;event loop&quot; based. Event loop is I think what you are really referring to, where a single event is processed from beginning to end, where flow is explicitly yielded back to a dispatcher for processing of another event.</p>
<p>Second, lets restrict this to single-core programming for a second. In any multicore environment you obviously need either multithreading or multiprocess design to get full utilization of your CPU. When &quot;possible&quot;, as in your threads don't really need to be sharing data, I advise multiprocess over multithread but that's for simplicity and safety. But when thinking about each single core in that multicore solution...</p>
<p>Event loop programming is way faster (and actually easier to write) when your items of work (the things to be accomplished by the event) are all relatively the same length in terms of execution time AND have few IO operations. You don't need to worry about concurrency/races and there's no context switching. The moment either of those two conditions are violated, and threading starts becoming the better solution.</p>
<p>In a single threaded environment, IO means either blocking (shitty for perf) or making that IO a new event, and hand-writing state to store to continue processing the overall event later. Its a hand-optimized version of threading. You can do it and the payoffs are large, but as the complexity of each item of work grows, or the amount of IO you have to do grows, you will be writing more and more state structures and the efficiency of your coding (not the code execution) just keeps slowing down. In its worst case, you may have non-IO operations that are just really CPU intensive that make you save state as well to just avoid holding up everything else and creating large latencies. I remember having to write state off for a large signal processing routine that ground the CPU for seconds, gritting my teeth wishing we had threading for that particular project.</p>
<p>So threading becomes increasingly tantalizing as those items of work grow in complexity. When you have lots of IO in one item of work, or some items of work take way longer than others, you probably want to separate those off into threads. When you find items of work that are similar in computational size and without vast amounts of IO, put those into state machines / event-loops.</p>
<p>The two can even co-exist in the same project, with some threads hosting event loops, and others dedicated to special long running tasks.</p></div>
</details>

        <details class="comment "
         id="comment-voat_5546884"
         data-depth="0"
         data-id="voat_5546884"
open>
    <summary class="comment-header">
        <span class="badge badge-light"
              title="Comment score: 2">
            2
        </span>
        <span class="byline text-muted">
            <span >
                <a class="user-link" href="../../../../user/RevanProdigalKnight/">u/RevanProdigalKnight</a>

            </span>
            
            
            
            <span title="Posted: 2016-06-18 03:02:50 UTC">18 Jun 2016 03:02</span>
        </span>
    </summary>
    <div class="md"><p>Not an expert, but here's my two cents:</p>
<p>Really, it all comes down to the question of what kind of tasks you're running and how interdependent they may or may not be. If you're running a whole bunch of really big, independent tasks, multi-threading is the way to go because then you can run them all in parallel. If you're running a whole bunch of really small interdependent tasks, then an asynchronous event-based model is probably a better choice. Then you have your typical muddy grey area in the middle where it's kind of up to what you feel like programming as to what's best.</p>
<p>To be honest though, Node.JS isn't the best choice for a server because it all runs in a single thread. You would need to make clusters of Node.JS servers just to get the equivalent of a single Apache server thanks to the fact that Apache is multi-threaded by nature. Regardless of multi-threaded or asynchronous programming model, you will get better performance out of a compiled language than you would with an interpreted language, and you'll get better performance across parallel sessions with a multi-threaded architecture.</p>
<p>Personally, I would love it if JavaScript interpreters added multithreading capabilities, because then there would be pretty much no question as to what the go-to language for a given task should be; you'd get the best of both worlds. At the same time, though, JavaScript still has a performance peak that it can't surpass since it is an interpreted language. The interpreters may get faster, or better at predicting how to run the code, but it still has to be interpreted at runtime, and that adds overhead that can't be ignored.</p></div>
</details>

        <details class="comment "
         id="comment-voat_5549637"
         data-depth="0"
         data-id="voat_5549637"
open>
    <summary class="comment-header">
        <span class="badge badge-light"
              title="Comment score: 1">
            1
        </span>
        <span class="byline text-muted">
            <span >
                <a class="user-link" href="../../../../user/SlappyHo/">u/SlappyHo</a>

            </span>
            
            
            
            <span title="Posted: 2016-06-18 12:39:24 UTC">18 Jun 2016 12:39</span>
        </span>
    </summary>
    <div class="md"><p>I recently wrote a P2P VoIP app that used threading for the capture, playback and audio mixing &amp; aysnc for the p2p mesh service. Each solve a different problem. Both are useful techniques.</p></div>
</details>

        <details class="comment "
         id="comment-voat_5550671"
         data-depth="0"
         data-id="voat_5550671"
open>
    <summary class="comment-header">
        <span class="badge badge-warning-orange"
              title="Comment score: 0">
            0
        </span>
        <span class="byline text-muted">
            <span >
                <a class="user-link" href="../../../../user/goatsandbros/">u/goatsandbros</a>

            </span>
            
            
            
            <span title="Posted: 2016-06-18 15:17:13 UTC">18 Jun 2016 15:17</span>
        </span>
    </summary>
    <div class="md"><p>You're not punting your comprehensives questions to Voat, are you?  ;)</p></div>
</details>

</div>
    </main>

<footer class="container-fluid">
  <a class="to-top mt-1 mb-1 btn btn-lg btn-primary" href="#top">top of page</a>
  <p class="small mb-0">
    last archived 28 Apr 2020
    <a href="https://github.com/19-84/redd-archiver">source code</a>
  </p>
</footer>
    </div>

  </body>
</html>